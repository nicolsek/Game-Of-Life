package main

import (
	"fmt"
	"math/rand"
	"os"
	"os/exec"
	"time"
)

/* Rules! */

/*

	1. Any live cell with fewer than two live neighbors dies, as if caused by underpopulation.
	2. Any live cell with two or three live neighbors lives on to the next generation.
	3. Any live cell with more than three live neighbors dies, as if by overpopulation.
	4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.

	(Rules taken from Wikipedia)

*/

func init() {
	rand.Seed(time.Now().UTC().UnixNano())
}

// main ... Main functions that begins the simulation of life and acts as a state based loop.
func main() {
	//Creating and passing a reference to the GOL object.
	gol := makeGOL()

	//While GOL is simulating.
	for gol.isSimulating {
		//Simulating using the reference to the GOL object.
		simulate(gol)
		//Draw the GOL cells.
		draw(gol)
		time.Sleep(time.Second)
	}

}

// GOL ... A struct that holds the required data for simulating and managing the Game of Life.
type GOL struct {
	cellSize     int
	cells        [8][8]int
	isSimulating bool
	hasStart     bool
}

// makeGOL ... Creates the GOL object and sets the running to true.
func makeGOL() *GOL {
	gol := new(GOL)
	gol.isSimulating = true
	gol.cellSize = len(gol.cells)
	//Will be used to reference the start of the simulation and to allow seeding.
	gol.hasStart = false

	return gol
}

// simulate ... Begins simulating the GOL and using the object alters the values and checks the rules.
func simulate(gol *GOL) {
	if !gol.hasStart {
		seedCells(gol)
		gol.hasStart = true
	}

	checkRules(gol)
}

// draw ... Draws the life
func draw(gol *GOL) {
	board := new([len(gol.cells)][len(gol.cells)]string)

	for cellsY := range gol.cells {
		for cellsX := range gol.cells {
			switch gol.cells[cellsX][cellsY] {
			case 0:
				board[cellsX][cellsY] = "_"

			case 1:
				board[cellsX][cellsY] = "*"
			}
		}
	}

	cmd := exec.Command("cmd", "/c", "cls")
	cmd.Stdout = os.Stdout
	cmd.Run()

	fmt.Printf("%v", board)
}

// seedCells ... Seeds the cells by using a random seed generated by the variable time between the the time.now and converting that to nano-seconds.
func seedCells(gol *GOL) {
	// -\(.-.)/- It's a way of seeding, don't judge me I'm 16.
	for cellsY := range gol.cells {
		for cellsX := range gol.cells {
			gol.cells[cellsX][cellsY] = rand.Intn(2)
		}
	}

}

// checkRules ... Goes through a list of the rules and iteratively checks them and does things if they pass or fail.
func checkRules(gol *GOL) {

	for cellsX := range gol.cells {
		for cellsY := range gol.cells {
			//Setting up the neighbors and will add from over time.
			neighbors := -gol.cells[cellsX][cellsY]

			for i := -1; i <= 1; i++ {
				for j := -1; j <= 1; j++ {
					//Get the value at the 3x3 array that is wrapped around the cell size and check if the neighbors are alive.
					neighbors += gol.cells[mod(cellsX+i, len(gol.cells))][mod(cellsY+1, len(gol.cells))]
				}

				//1. Any live cell with fewer than two live neighbors dies, as if caused by underpopulation.
				if neighbors < 2 {
					gol.cells[cellsX][cellsY] = 0
				}

				//3. Any live cell with more than three live neighbors dies, as if by overpopulation.
				if neighbors == 3 {
					gol.cells[cellsX][cellsY] = 1
				}

				//4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.
				if neighbors >= 3 {
					gol.cells[cellsX][cellsY] = 0
				}

			}
		}
	}
}

// mod ... Mods a with b
func mod(a, b int) int {
	return ((a % b) + b) % b
}
