package main

import (
	"fmt"
	"math/rand"
	"os"
	"os/exec"
	"time"
)

/* Rules! */

/*

	1. Any live cell with fewer than two live neighbors dies, as if caused by underpopulation.
	2. Any live cell with two or three live neighbors lives on to the next generation.
	3. Any live cell with more than three live neighbors dies, as if by overpopulation.
	4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.

	(Rules taken from Wikipedia)

*/

// main ... Main functions that begins the simulation of life and acts as a state based loop.
func main() {

	//Find out if the user wants to load a custoom map and assigns values dependant on that.
	// customMap, loadMap := queryMaps("gol/")

	//Creating and passing a reference to the GOL object.
	gol := makeGOL()
	//While GOL is simulating.
	for gol.isSimulating {
		//Simulating using the reference to the GOL object.
		simulate(gol)

		//Draw the GOL cells.
		draw(gol)
		time.Sleep(time.Second / 7)
	}

}

// GOL ... A struct that holds the required data for simulating and managing the Game of Life.
type GOL struct {
	cellSize     int
	cells        [64][64]int
	isSimulating bool
	hasStart     bool
	customMap    bool
	mapInfo      os.FileInfo
}

// makeGOL ... Creates the GOL object and sets the running to true.
func makeGOL() *GOL {
	gol := new(GOL)
	gol.isSimulating = true
	gol.cellSize = len(gol.cells)
	//Will be used to reference the start of the simulation and to allow seeding.
	gol.hasStart = false
	// gol.customMap = loadMap

	// if gol.customMap {
	// 	gol.cells = customMap.values
	// }

	return gol
}

// CustomMap ... Sets up the custom file format container.
type CustomMap struct {
	size   int
	values [][]int
}

// simulate ... Begins simulating the GOL and using the object alters the values and checks the rules.
func simulate(gol *GOL) {
	if !gol.hasStart {
		seedCells(gol)
		gol.hasStart = true
		// if !gol.hasStart && gol.customMap {
		// 	loadMap(gol.mapInfo)
		// 	gol.hasStart = true
		// }
	} else {
		checkRules(gol)
	}
}

// draw ... Draws the life
func draw(gol *GOL) {
	board := ""

	for cellsY := range gol.cells {
		for cellsX := range gol.cells {
			if cellsX == 0 {
				board += "\n"
			}

			switch gol.cells[cellsX][cellsY] {

			case 0:
				board += " "

			case 1:
				board += "â– "
			}

		}
	}

	cmd := exec.Command("cmd", "/c", "cls")
	cmd.Stdout = os.Stdout
	cmd.Run()

	fmt.Println(board)
}

// seedCells ... Seeds the cells by using a random seed generated by the variable time between the the time.now and converting that to nano-seconds.
func seedCells(gol *GOL) {
	// -\(.-.)/- It's a way of seeding, don't judge me I'm 16.
	rand.Seed(time.Now().UTC().UnixNano())

	for cellsY := range gol.cells {
		for cellsX := range gol.cells {
			gol.cells[cellsX][cellsY] = rand.Intn(2)
		}
	}

}

// checkRules ... Goes through a list of the rules and iteratively checks them and does things if they pass or fail.
func checkRules(gol *GOL) {

	for cellsY := range gol.cells {
		for cellsX := range gol.cells {
			//Setting up the neighbors and will add from over time.

			neighbors := 0

			for i := -1; i <= 1; i++ {
				for j := -1; j <= 1; j++ {
					if i != 0 && j != 0 {
						if cellsX+i > 0 && cellsX+i < len(gol.cells) && cellsY+j > 0 && cellsY+j < len(gol.cells) {
							if gol.cells[cellsX+i][cellsY+j] == 1 {
								neighbors++
							}
						}
					}
				}
			}

			//1. Any live cell with fewer than two live neighbors dies, as if caused by underpopulation.
			if neighbors < 2 {
				gol.cells[cellsX][cellsY] = 0
			}

			//4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.
			if neighbors == 3 {
				gol.cells[cellsX][cellsY] = 1
			}

			//3. Any live cell with more than three live neighbors dies, as if by overpopulation.
			if neighbors > 3 {
				gol.cells[cellsX][cellsY] = 0
			}
		}
	}
}

// func queryMaps(path string) (*CustomMap, bool) {
// 	files, _ := ioutil.ReadDir(path)

// 	fmt.Printf("Would you like to load any of these maps? Type in the desired map id or N to generate a random map.\n")

// 	for i := 0; i < len(files); i++ {
// 		fmt.Printf("ID: %v. Map: %v\n", i, files[i].Name())
// 	}

// 	reader := bufio.NewReader(os.Stdin)
// 	text, _ := reader.ReadString('\n')

// 	doLoad := true

// 	customMap := new(CustomMap)
// 	fmt.Printf("%v\n", text == "N")
// 	if text == "N" {
// 		customMap.size = 64
// 		customMap.values = make([][]int, customMap.size)
// 	}

// 	if text != "N" {
// 		id, _ := strconv.Atoi(text)

// 		customMap = loadMap(files[id])

// 	}

// 	if text == "N" {
// 		doLoad = false
// 	}

// 	return customMap, doLoad

// }

// func loadMap(mapInfo os.FileInfo) *CustomMap {
// 	thisMap := new(CustomMap)

// 	file, _ := ioutil.ReadFile("gol/" + mapInfo.Name())

// 	thisMap.size, _ = strconv.Atoi(string(file[0]))
// 	thisMap.values = make([][]int, thisMap.size)

// 	c := 0
// 	x := 0
// 	y := 0

// 	for char := range file {
// 		thisMap.values[x][y], _ = strconv.Atoi(string(file[c]))
// 		c++
// 		x++
// 		if char == '\n' {
// 			y++
// 			x %= thisMap.size
// 		}
// 	}

// 	return thisMap
// }

// mod ... Mods a with b
func mod(a, b int) int {
	return ((a % b) + b) % b
}
